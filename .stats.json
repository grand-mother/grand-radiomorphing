{"lines": {"blank": 298, "comment": 62, "docstring": 529, "code": 1191}, "pep8": {"count": 472, "categories": [["6", "E114", "indentation is not a multiple of four (comment)"], ["6", "E116", "unexpected indentation (comment)"], ["1", "E127", "continuation line over-indented for visual indent"], ["1", "E261", "at least two spaces before inline comment"], ["147", "E265", "block comment should start with '# '"], ["1", "E266", "too many leading '#' for block comment"], ["4", "E402", "module level import not at top of file"], ["245", "E501", "line too long (95 > 79 characters)"], ["1", "E722", "do not use bare 'except'"], ["3", "E741", "ambiguous variable name 'l'"], ["53", "W291", "trailing whitespace"], ["4", "W293", "blank line contains whitespace"]]}, "doc": {"statistics": {"grand_radiomorphing/scaling.py": {"tokens": {"root_dir": [13, ["Missing description"]], "_scalingpulse": [222, ["Unknown parameter `dist2`", "Undocumented parameter `l`"]], "_scale_run": [451, ["Undocumented parameter `dist1`", "Unknown parameter `dist2`", "Undocumented parameter `primary`", "Undocumented parameter `run`", "Undocumented parameter `sim_dir`"]]}, "n_errors": 8, "n_tokens": 77}}, "doc": "Produce radio signals with Radio Morphing", "classes": {}, "definitions": {}, "functions": {"scale": [564, "Scale all simulated traces to the shower parameters\n", {"parameters": {"sim_dir": ["str", "path to older containing the files of the reference shower"], "primary": ["str", "primary for target shower, for now it just excepts 'electron' or 'pion'"], "energy": ["float", "primary energy of target shower in EeV"], "zenith": ["float", "zenith angle of primary of target shower in radian"], "azimuth": ["float", "azimuth angle of primary of target shower in radian"], "injection_height": ["float", "injectionheight of particle for target shower in meters"], "altitude": ["float", "usually same as injh2, but there could be exceptions"]}, "prototype": "sim_dir, primary, energy, zenith, azimuth, injection_height, altitude", "returns": [["-", "Start the scaling and isometry process of the simulated reference shower acoording to target shower parameters", ""]]}, "grand_radiomorphing/scaling.py"], "interpolate": [73, "Interpolate all traces from the (rescaled) closest neighbours\n    - first the closest neighbours to a desired antenna positions get identified,\n        traces and positions are handed over to the interpolation function,\n        calculated signal traces get stored.          \n", {"parameters": {"path0": ["str", "path to file with desired antenna positions"], "path1": ["str", "path to the simulations"], "path2": ["str", "path to the folder for final traces"], "zenith": ["float", "zenith angle of the morphed shower, in degrees"], "azimuth": ["float", "azimuth angle of the morphed shower, in degrees"], "injection_height": ["float", "geometrical height of shower injection"], "scaled": ["bool", "flag for interpolating from a non scaled shower"]}, "prototype": "path0, path1, path2, zenith=None, azimuth=None, injection_height=None, scaled=True", "returns": []}, "grand_radiomorphing/core.py"], "process": [832, "Rescale and interpolate the radio traces for all antennas \n    - start the Radio Morphing procedure\n", {"parameters": {"sim_dir": ["str", "path to the simulated traces"], "shower": ["dict", "properties of the requested shower"], "antennas": ["str", "path the requested antenna positions"], "out_dir": ["str", "path where the output traces should be dumped"]}, "prototype": "sim_dir, shower, antennas, out_dir"}, "grand_radiomorphing/core.py"]}, "imports": {"1": {"scaling": [["scale", "scale"]], "core": [["interpolate", "interpolate"], ["process", "process"]]}}, "path": "grand_radiomorphing/__init__.py", "__all__": ["core", "frame", "interpolation", "scaling", "utils"], "modules": {"core": {"doc": "Start the interpolation of the signal at a desired antenna position \non the basis of the rescaled electric field traces and the antenna position after the isometry.\n#\nNotes: \nThis script does the preperation for a interpolation of a complete pulse at any antenna position you desire.\nTherfore, you have to hand over a list of antenna position you would like to have, a file containing the \nsimulations which should be use (names of the planes) and a path whre to find these simlations\nthe script calculates all the prjections on the exiting planes which are needed, and hand the traces \nand positions over to the interpolation script which performs the interpoaltion alwys in between two positions\nwhether you wanna use filtered traces is set in this script by hand at the beginning\nTt returns files (t, Ex,Ey,Ez) in a folder, named InterpoaltedSignals, if it exists. ", "classes": {}, "definitions": {}, "functions": {"interpolate": [73, "Interpolate all traces from the (rescaled) closest neighbours\n    - first the closest neighbours to a desired antenna positions get identified,\n        traces and positions are handed over to the interpolation function,\n        calculated signal traces get stored.          \n", {"parameters": {"path0": ["str", "path to file with desired antenna positions"], "path1": ["str", "path to the simulations"], "path2": ["str", "path to the folder for final traces"], "zenith": ["float", "zenith angle of the morphed shower, in degrees"], "azimuth": ["float", "azimuth angle of the morphed shower, in degrees"], "injection_height": ["float", "geometrical height of shower injection"], "scaled": ["bool", "flag for interpolating from a non scaled shower"]}, "prototype": "path0, path1, path2, zenith=None, azimuth=None, injection_height=None, scaled=True", "returns": []}], "process": [832, "Rescale and interpolate the radio traces for all antennas \n    - start the Radio Morphing procedure\n", {"parameters": {"sim_dir": ["str", "path to the simulated traces"], "shower": ["dict", "properties of the requested shower"], "antennas": ["str", "path the requested antenna positions"], "out_dir": ["str", "path where the output traces should be dumped"]}, "prototype": "sim_dir, shower, antennas, out_dir"}]}, "imports": {}, "path": "grand_radiomorphing/core.py"}, "frame": {"doc": "Collection of functions used for local frame transforms for pulse shape computations.", "classes": {}, "definitions": {}, "functions": {"get_rotation": [6, "Utility function for getting the rotation matrix between frames\n", {"parameters": {"zen": ["float", "zenith angles of primary in radian"], "az": ["float", "azmimuth angle in radian"], "phigeo": ["float", "magnetic field angles in radian"], "bfieldangle": ["float", "magnetic field angles in radian"]}, "prototype": "zen, az, phigeo, bfieldangle", "returns": []}], "UVWGetter": [38, "Closure for getting coordinates in the shower frame.\n", {"parameters": {"cx": ["float", "position vector - x component, in meters"], "cy": ["float", "position vector - y component, in meters"], "cz": ["float", "position vector - z component, in meters"], "zen": ["float", "zenith angles of primary in radian"], "az": ["float", "azmimuth angle in radian"], "phigeo": ["float", "magnetic field angles in radian"], "bfieldangle": ["floats", "magnetic field angles in radian"]}, "prototype": "cx, cy, cz, zen, az, phigeo, bfieldangle", "returns": []}], "XYZGetter": [69, "Closure for getting back to the main frame\n", {"parameters": {"cx": ["float", "position vector - x component, in meters"], "cy": ["float", "position vector - y component, in meters"], "cz": ["float", "position vector - z component, in meters"], "zen": ["float", "zenith angles of primary in radian"], "az": ["float", "azmimuth angle in radian"], "phigeo": ["float", "magnetic field angles in radian"], "bfieldangle": ["float", "magnetic field angles in radian"]}, "prototype": "cx, cy, cz, zen, az, phigeo, bfieldangle", "returns": []}]}, "imports": {}, "path": "grand_radiomorphing/frame.py"}, "interpolation": {"doc": "Script to perform an interpolation between to electric field traces at a desired position\n(called by core.py)\n\nIt needs as input antenna position 1 and 2, their traces (filtered or not) in one component, their time, \nand the desired antenna position\nand returns the trace ( in x,y,z coordinate system) and the time from the desired antenna position\nZeroadding and upsampling of the signal are optional functions\n\nIMPORTANT NOTE:\nThe interpolation of the phases includes the\ninterpolation of the signal arrival time. A linear interpolation implies a plane radio\nemission wave front, which is a simplification as it is hyperbolic in shape. However, \nthe wave front can be estimated as a plane between two simu-\nlated observer positions for a sufficiently dense grid of observers, as then parts of\nthe wave front are linear on small scales.\n\nThis script bases on the diploma thesis of Ewa Holt (KIT, 2013) in the context of AERA/AUGER. \nIt is based on the interpolation of the amplitude and the pahse in the frequency domain. \nThis can lead to misidentifiying of the correct phase. We are working on the interplementaion \non a more robust interpolation of the signal.\nFeel free to include it if you have some time to work on it. The script is completely modular \nso that single parts can be substitute easily.", "classes": {}, "definitions": {}, "functions": {"unwrap": [61, "Unwrap the phase to a strictly decreasing function.\n", {"parameters": {"phi": ["numpy array, float", "phase of the signal trace"], "ontrue": ["str", "printing option, default=None"]}, "prototype": "phi, ontrue=None", "returns": [["numpy array, float", "unwarpped phase of the signal trace", "phi_unwrapped"]]}], "interpolate_trace": [92, "Interpolation of signal traces at the specific position in the frequency domain\n", {"parameters": {"t1": ["numpy array, float", "time in ns of antenna 1"], "trace1": ["numpy array, float", "single component of the electric field's amplitude of antenna 1"], "x1": ["numpy array, float", "position of antenna 1"], "t2": ["numpy array, float", "time in ns of antenna 2"], "trace2": ["numpy array, float", "single component of the electric field's amplitude of antenna 2"], "x2": ["numpy array, float", "position of antenna 2"], "xdes": ["numpy arry, float", "antenna position for which trace is desired, in meters"], "upsampling": ["str", "optional, True/False, performs upsampling of the signal, by a factor 8"], "zeroadding": ["str", "optional, True/False, adds zeros at the end of the trace of needed"], "ontrue": ["str", "optional, True/False, just a plotting command"], "flow": ["float", "lower frequency - optional, define the frequency range for plotting, if desired (DISPLAY=True/False)"], "fhigh": ["float", "higher frequency - optional, define the frequency range for plotting, if desired (DISPLAY=True/False)"]}, "prototype": "t1, trace1, x1, t2, trace2, x2, xdes, upsampling=None, zeroadding=None, ontrue=None, flow=60000000.0, fhigh=200000000.0", "returns": [["numpy array, float", "time for signal at desired antenna position in ns", "xnew"], ["numpy array, float", "interpolated electric field component at desired antenna position", "tracedes"]]}]}, "imports": {}, "path": "grand_radiomorphing/interpolation.py"}, "scaling": {"doc": "Performs the scaling of given electric field traces and the isometry \nof the antenna positions for a reference shower according to the parameters of a target shower", "classes": {}, "definitions": {"root_dir": [13, "", null]}, "functions": {"scale": [564, "Scale all simulated traces to the shower parameters\n", {"parameters": {"sim_dir": ["str", "path to older containing the files of the reference shower"], "primary": ["str", "primary for target shower, for now it just excepts 'electron' or 'pion'"], "energy": ["float", "primary energy of target shower in EeV"], "zenith": ["float", "zenith angle of primary of target shower in radian"], "azimuth": ["float", "azimuth angle of primary of target shower in radian"], "injection_height": ["float", "injectionheight of particle for target shower in meters"], "altitude": ["float", "usually same as injh2, but there could be exceptions"]}, "prototype": "sim_dir, primary, energy, zenith, azimuth, injection_height, altitude", "returns": [["-", "Start the scaling and isometry process of the simulated reference shower acoording to target shower parameters", ""]]}]}, "imports": {}, "path": "grand_radiomorphing/scaling.py"}, "utils": {"doc": "File collecting useful functions", "classes": {}, "definitions": {}, "functions": {"load_trace": [7, "Load data from a trace file\n", {"parameters": {"directory": ["str", "path to file"], "index": ["ind", "index number of antenna"], "suffix": ["str", "optional, suffix of file"]}, "prototype": "directory, index, suffix='.trace'", "returns": []}], "getn": [29, "Get the refractive index\n\n    Reference:\n     Zhaires (see email M. Tueros 25/11/2016)\n", {"parameters": {"h": ["float", "height in meters at which one wants to have the refractive index"]}, "prototype": "h", "returns": [["float", "refractive angle", ""]]}], "getCerenkovAngle": [50, "Get the Cerenkov angle\n", {"parameters": {"h": ["float", "height in meters at which one wants to have the Cherenkov angle"]}, "prototype": "h", "returns": [["float", "Cherenkov angle in radian", ""]]}], "get_integratedn": [67, "Returns the effectiv/integrated refractive index at a specific height.\n", {"parameters": {"zen2": ["float", "zenith angle in radian at the starting point at height injh2"], "injh2": ["float", "height in meters of the starting point, assuming it is defines as (0,0,injh2)"], "position": ["numpy array", "defines endposition for integration (= observer position)"]}, "prototype": "zen2, injh2, position", "returns": [["float", "effectiv referactive index along the shower trajectory", "n"]]}], "mag": [136, "Calculate absolute value of x\n", {"parameters": {"x": ["numpy array, floats", "vector"]}, "prototype": "x", "returns": [["float", "absolute value of vector", ""]]}]}, "imports": {}, "path": "grand_radiomorphing/utils.py"}}}}